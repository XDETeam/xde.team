import React from "react";
import { Layout } from "../../../templates/layout";

//TODO:
export const Prerequisites = () => <>
	<a>Важность реюзинга</a>
	<a>Функция</a>
</>;

export const Mesh = () => (
	<Layout>
		<header>
			<h1>Функциональное программирование</h1>
		</header>

		<section>
			<h2>"Специфичный" подход</h2>

			<p>
				Давайте представим, что перед нами встала задача написать модуль,
				осуществляющий некоторое сложное вычисление. Поскольку само вычисление
				в данном контексте не важно, мы упростим его до деления двух чисел и
				опишем простой спецификацией:
			</p>

			<table className="simple">
				<thead>
					<tr>
						<th>Значение</th>
						<th>Тип</th>
						<th>Описание</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Аргумент "x"</td>
						<td>Число</td>
						<td>Делимое</td>
					</tr>
					<tr>
						<td>Аргумент "y"</td>
						<td>Число</td>
						<td>Делитель</td>
					</tr>
					<tr>
						<td>Результат</td>
						<td>Число</td>
						<td>Частное</td>
					</tr>
				</tbody>
			</table>

			<p>
				Программа была успешно внедрена и долгое время всё было хорошо, пока не стали
				возникать ошибки. Проблему удалось быстро диагностировать и причиной оказалось
				деление на ноль. Настало время внести эту коррективу с спецификацию:
			</p>

			<table className="simple">
				<thead>
					<tr>
						<th>Значение</th>
						<th>Тип</th>
						<th>Описание</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Аргумент "x"</td>
						<td>Число</td>
						<td>Делимое</td>
					</tr>
					<tr>
						<td>Аргумент "y"</td>
						<td>Число</td>
						<td>Делитель</td>
					</tr>
					<tr>
						<td>Результат</td>
						<td className="highlight">Число или ошибка деления на ноль</td>
						<td>Частное</td>
					</tr>
				</tbody>
			</table>

			<p>
				Теперь мы знаем, что помимо числового решения при некоторых обстоятельствах
				мы можем получить побочный эффект.
			</p>

			<p>
				Функциональный программирование в рамках "специфичного" подхода &mdash; это
				когда сигнатура функции выступает в роли спецификации. В нашем примере:
			</p>

			<code>{`
// Плохая спецификация
function Divide(x: int, y:int): int;

// Хорошая спецификация
function Divide(x: int, y: int): (int | DivideByZeroError);
			`}</code>

			<p>
				С учётом классической модели, что Output = Program(Input), такой подход может
				специфицировать практически всё приложение целиком.
			</p>

			<p>
				Теперь представим себя разработчиками, который использовали эту функцию
				деления в длинной цепочке вычислений:
			</p>

			<code>{`
a2 = div(a0, a1)
a3 = sqrt(a2)
a4 = 2*pi*a3
a5 = cos(a4)
			`}</code>

			<p>
				Как только мы внесли изменение и добавили возможность возврата ошибки,
				компилятор отказывает собирать наш код. С точки зрения надёжности это
				хорошо, но неработающая программа - плохо.
			</p>

			<p>
				Очевидно, что заставлять разработчиков всех остальных функций вносить
				изменения, обеспечивающие поддержку информации об ошибке нереально.
				Поэтому в индустрии было придумано самое простое решение - выбрасывать
				исключение. Это по сути паника локального масштаба. Мы останавливаем
				вычисление и надеемся, что кто-то "наверху" знает, что делать с этой
				ситуацией. Решение, мягко говоря, далекое от гибкости и универсальности.
			</p>

			<p>
				Чтобы получить больше контроля, представим себе некоторый вычислитель,
				который знает о возможности существовании ошибки в результате и реализует
				простую стратегию. Мы ему последовательно передаем вычисления, которые
				хотим осуществить. Если он видит нормальный результат, то осуществляет
				вычисление, в противном случае также возвращет ошибку. То есть:
			</p>

			<code>{`
value = div(a0, a1)
value = calc(value, x => sqrt(x))
value = calc(value, x => 2*pi*x)
value = calc(value, x => cos(x))
			`}</code>

			<p>
				Подобные вычислители получили в функциональном программировании название
				"монада". Первая строка реализует то, что принято называть pure-функцией
				монады,а остальные - bind.
			</p>
		</section>

		<section>
			<h2>"Грязные" эффекты</h2>

			<p>
				Часто можно услышать, что эффекты - это ввод/вывод, исключения и другие
				подобные аспекты. Но если представить себе программу, основная задача
				которой будет вывод на экран байт за байтом полученные данные из сетевого
				сокета, то несмотря на обилие "грязных" критериев, к ней сложно будет
				придраться.
			</p>

			<p>
				Проблемы возникают, когда что-то начинает происходить скрыто. Например,
				мы занимаемся разработкой пользовательского интерфейса для программы
				деления описанной выше. И для нас начинает представлять проблему, если
				побочный эффект от деления на ноль не специфицирован.
			</p>

			<p>
				TODO: Исключения могут быть, но это вопрос рантайма, который их будет
				обрабатывать? Так я могу более логично перейти к аспектному подходу.
			</p>
		</section>

		<section>
			<h2>Чистые функции и эффекты</h2>

			<p>
				TODO:Обычно определяют функциональные языки через чистоту функций. Во-первых, надо
				будет сделать сноску, что функциональный язык не тот, где всё чисто, а тот который
				может умело разделить основные задачи и эффекты.
			</p>

			<p>
				TODO:Функция деления. Выглядит достаточно чистой, но что если будет деление на ноль.
				Может объединить функциональный подход со спецификациями. Смысл в том, что определив
				функцию деления как просто Int &rarr; Int мы специфицируем её не до конца. Даже
				командный процессор может не иметь доступа к консоли (пример с хостингом Powershell
				и не путать с консольным приложением).
			</p>

			<p>
				TODO:Чистые данные - это данные, которые я хочу получить. Грязные данные содержат
				дополнительную информацию.
			</p>
		</section>

		<section>
			<h2>Монады</h2>

			<p>
				Представим себе существование некоторого объекта, скажем число 5. К нему может быть
				применена некоторая функция. Например f(x) = x*2. Дальше, большинство евангелистов
				предлагает преставить себе либо некоторый ящик, либо контекст. И речь идёт о том,
				что применение функции f теперь уже будет зависеть от контекста (возможно не стоит
				думать о применении функции к ящику и вообще о ящике).
			</p>

			<p>
				Например, монада Maybe. Когда этот ящик открывается, там может оказаться либо 5,
				либо ничего. type Maybe a = Just a | Nothing. И вот здесь возникает вопрос, как
				применить функцию f к этом ящику? И вот здесь появляется функтор (fmap).
			</p>

			<p>
				Решение проблемы побочных эффектов? Возможно речь идёт о любых попутных вычислениях?
				Например, была такая цитата: "Аппликативный функтор работает только с чистыми функциями,
				т. е. в случае аппликативного функтора вы можете совершать над элементами контейнера
				только операции без побочных эффектов (т.е. операции, которые никогда не могут вернуть
				сам контейнер). Монада же позволяет применять к значениям внутри контейнера любые операции,
				в том числе и с побочными эффектами (т.е. возвращающие контейнер того же рода).
			</p>

			<p>
				Монады позволяют чистым функциональным языкам осуществлять императивные по сути
				операции, такие, как ввод-вывод и обработку исключений.
			</p>

			<p>
				Простой пример монады - Option. Показать на примере простых математических операций.
			</p>

			<p>
				Показать сравнение, как "протаскивает" значение классическом исключение и как это
				делает монада (Result или кто там).
			</p>

			<p>
				Собрать как можно больше примеров монад: LINQ, генераторы списков, continuations,
				Maybe, Option, await/async/Task.
			</p>
		</section>

		<section>
			<h2>Вопросы</h2>

			<p>
				Предположим, что у нас есть функция вычисления факториала. Она реализована рекурсивно.
				Для ускорения работы факториала мы решили добавить мемоизацию в эту функцию. Как это
				лучше сделать если предположить, что у человека расширяющего исходную функцию нет
				доступа к её коду?
			</p>
		</section>

		<section>
			<h2>InBox</h2>

			<p>
				Монадические аспекты. Например, вычисление значений функции и вывод на экран, это
				функция, которая аспектами значения и с отображения на экране.
			</p>

			<p>Bind описывает flow в некотором смысле.</p>
		</section>
	</Layout>
);

export default Mesh;
